## 4.5 JNI字段和方法操作效率

学完了如何缓存字段和方法ID来提高效率，你也许疑惑：使用JNI访问字段和调用方法的效率怎么样？本地代码的回调（native/java回调）、调用本地方法（java调用native）以及普通方法（java调用java）的消耗如何？

毫无疑问，这个问题的答案取决于实现JNI的虚拟机的效率。因此，不可能给出一个准确的效率特性。但是，我们可以分析固有的本地方法调用和JNI操作字段和方法效率，为JNI程序员和实现者提供一个大致的效率指导。

我们先从java/native调用和java/java调用的效率比较。java/native调用比java/java调用要慢，原因如下：

* 本地方法与虚拟机内部的java/java调用有一些方式上的不同。因此，虚拟机必须在跳转到本地方法的起始指针之前，执行额外的操作创建参数和设置栈帧。
* 对于虚拟机，内联方法调用很常见。而java/native调用比java/java调用难很多。

我们估计，一个典型的虚拟机执行java/native调用会比java/java调用慢2~3倍。因为一个java/java调用只需要几个周期（cycles），增加的开销可以忽略不计，除非本地方法执行琐碎的操作。同样也可能通过调整虚拟机的实现，使得java/native的消耗接近或者等于java/java的消耗。（例如，这样的虚拟机实现可以适应JNI调用约定和内部的java/java约定相同）

技术上来讲，native/java调用和java/native调用相似。理论上来讲，native/java回调的额外消耗是java/java的2到3倍。然而，在实际应用中，native/java回调比较少见。虚拟机实现往往不会优化回调的性能。多数虚拟机中，native/java调用的消耗可以达到java/java调用的10倍。

使用JNI访问字段的消耗取决于通过JNIEnv进行调用的消耗。与直接废弃引用对象，本地代码不得不执行一个C函数调用相应的废弃引用对象。这个函数调用时必须的，因为它把本地代码和虚拟机中保持的内部对象表示隔离开。JNI字段访问开销通常可以忽略不计，因为函数调用占用几个周期（cycles）。



